DONE - player actions: cast, reel shop, move (to a different pond)
DONE - instantiate many fish objects at once: we do this in ex45_locations
  # by calling a block on each fish Class and iterating with .new
DONE - look into saving progress via YAML
DONE - tell Ruby to wait while "fishing": use sleep(seconds)
DONE - some sort of casting graphic (/\/\/\ waves): in ex45_graphics.rb
DONE - can sell fish for bait
- better bait = better fish
- fish saved in aquarium (graphic representation?)
- later: predatory fish?  have to battle certain fish?
- feeding aquarium fish?
DONE - reeling in vs just automatically catching (battlefish)
  # a fishing mini-game! like battleship with fish
- Classes: fish, fish types, aquarium, ponds, shop, player
- Kyle suggestion: spawn_fish method that returns fish type to spawn based on
  # percentages (e.g. 20% chance to spawn Trout, etc.)
DONE - using bait: if catching fish has a random chance of working, bait just
  # increases that chance.  E.g. fishing rand = (1..10) with bait rand = (5..10)
  # success = 8 or higher

TODO:
DONE - fix answer accepting lowercase
DONE - fix can give same answer twice
- bomb bait? reveals tiles around where you drop it
DONE - add bait logic: Player Class now contains an inventory with bait +
  # catching a fish removes 1 bait from inventory
- add graphics for bigger fish
- call different fish graphics depending on size of fish caught
DONE - if keep fishing, don't show casting animation every time: play method
  # tracks last action and sends to fishing method
DONE - add shop (should the shop be a Location itself?)
DONE - setup player input (keep fishing, move location, shop, etc.): play method
  # manages this with a loop
DONE - add option to save and continue or save and quit
DONE - ask to save before quitting
DONE - anything else we should save?: we now save the entire Game object which
  # includes locations, player, etc.
- graphics upon moving - e.g. "welcome to the ocean" with a palm tree
DONE - populate grid with headers for columns / rows (A, B, C / 1, 2, 3)
  # so players can guess "A2" == [0][1]
DONE - create battlefish guessing game
DONE - game visual grid should show the location grid, not the valid fish grid
  # so whatever method ends up "displaying" the grid to the player
  # should call something like game.world.game_visual(game.world.current_location.grid)
  # 1) fish location grid
  # 2) grid player sees and edits - base is location grid and changes based on
  # fish location grid + player inputs
  # fish location grid never changes or is edited
  # fish grid and working grid should be instance variables that are changed by methods
  # the visual representation should just be the dressing before showing to the player
  # don't store the visual representation grid anywhere (or you'll end up with multiple headers, etc.)
  # use a hash to translate between player input (A2) and array location?
  # e.g. {"A" => 1, "2" => 3} etc.
DONE - add bait logic back in to battlefish
- find treasures?
DONE - check if player minigame guess is valid - used regex and answer key comparison
DONE - make minigame a class instead of a module? (Kyle: feed any World variables it needs as arguments)
- replenish fish in each location upon loading (unless over-fishing is a mechanic)

NOTES:
- bait adjustment options: if we add have_bait? after the rand is generated
  # it increases the chances for success too much
  # e.g. in rand(3..10) there are 4 failures and 4 successes: 50/50
  # in rand(3..10) + 2 there are 2 failures and 6 successes: 25/75
  # in rand(5..10) (adding bait in before the generation)
  # there are 2 failures and 4 successes: 33/66
  # rand(3..10) [3, 4, 5, 6, 7, 8, 9, 10] = 4 bad, 4 good
  # ra(3..10)+2 [5, 6, 7, 8, 9, 10, 11, 12] = 2 bad, 6 good
  # rand(5..10) [5, 6, 7, 8, 9, 10] = 2 bad, 4 good
